#
# Copyright (c) 2018,2019 - Adjacent Link LLC, Bridgewater, New Jersey
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of Adjacent Link LLC nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# See toplevel COPYING for more information.
#

'''
NTP Probe
'''

import time
import ntplib

from otestpoint.interface import Probe
from otestpoint.interface.measurementtable_pb2 import MeasurementTable
import otestpoint.toolkit.logger as Logger
from otestpoint.time.ntp_pb2 import Measurement_time_ntp
import sys

import subprocess32
import json
import re

# Shell out to 'ntpq -p'
proc = subprocess32.Popen(['/usr/sbin/ntpq', '-np'], stdout=subprocess32.PIPE)

# Get the output
stdout_value = proc.communicate()[0].decode("utf-8")

#remove the header lines
start = stdout_value.find("===\n")

if start == -1:
    # We may be running on windows (\r\n), try \r...
    start = stdout_value.find("===\r")

    if start == -1:
        # No, go, exit with error
        result = {'query_result': 'failed', 'data': {}}
        print(json.dumps(result))
        sys.exit(1)

# Get the data part of the string
#pay_dirt = stdout_value[start+4:]
pay_dirt = stdout_value[start:]

# search for NTP line starting with * (primary server)
exp = ("\*((?P<remote>\S+)\s+)"
       "((?P<refid>\S+)\s+)"
       "((?P<st>\S+)\s+)"
       "((?P<t>\S+)\s+)"
       "((?P<when>\S+)\s+)"
       "((?P<poll>\S+)\s+)"
       "((?P<reach>\S+)\s+)"
       "((?P<delay>\S+)\s+)"
       "((?P<offset>\S+)\s+)"
       "((?P<jitter>\S+)\s+)")

regex = re.compile(exp, re.MULTILINE)
r = regex.search(pay_dirt)
if not r:
    # No, try again without the * at the beginning, get
    # the first entry instead
    exp = (" ((?P<remote>\S+)\s+)"
           "((?P<refid>\S+)\s+)"
           "((?P<st>\S+)\s+)"
           "((?P<t>\S+)\s+)"
           "((?P<when>\S+)\s+)"
           "((?P<poll>\S+)\s+)"
           "((?P<reach>\S+)\s+)"
           "((?P<delay>\S+)\s+)"
           "((?P<offset>\S+)\s+)"
           "((?P<jitter>\S+)\s+)")

    regex = re.compile(exp, re.MULTILINE)
    r = regex.search(pay_dirt)

data = {}

if r:
    data = r.groupdict()
print(data)


drift = None
last_refresh = 0
NTP_RETRIES=6
NTP_VERSION=3


class NTP(Probe):

    def dictio(self):
        proc = subprocess32.Popen(['/usr/sbin/ntpq', '-np'], stdout=subprocess32.PIPE)

# Get the output
        stdout_value = proc.communicate()[0].decode("utf-8")

#remove the header lines
        start = stdout_value.find("===\n")

        if start == -1:
    # We may be running on windows (\r\n), try \r...
            start = stdout_value.find("===\r")

            if start == -1:
        # No, go, exit with error
                result = {'query_result': 'failed', 'data': {}}
                print(json.dumps(result))
                sys.exit(1)

# Get the data part of the string
#pay_dirt = stdout_value[start+4:]
        pay_dirt = stdout_value[start:]

        # search for NTP line starting with * (primary server)
        exp = ("\*((?P<remote>\S+)\s+)"
               "((?P<refid>\S+)\s+)"
               "((?P<st>\S+)\s+)"
               "((?P<t>\S+)\s+)"
               "((?P<when>\S+)\s+)"
               "((?P<poll>\S+)\s+)"
               "((?P<reach>\S+)\s+)"
               "((?P<delay>\S+)\s+)"
               "((?P<offset>\S+)\s+)"
               "((?P<jitter>\S+)\s+)")

        regex = re.compile(exp, re.MULTILINE)
        r = regex.search(pay_dirt)

        if not r:
            exp = (" ((?P<remote>\S+)\s+)"
                  "((?P<refid>\S+)\s+)"
                  "((?P<st>\S+)\s+)"
                  "((?P<t>\S+)\s+)"
                  "((?P<when>\S+)\s+)"
                  "((?P<poll>\S+)\s+)"
                  "((?P<reach>\S+)\s+)"
                  "((?P<delay>\S+)\s+)"
                  "((?P<offset>\S+)\s+)"
                  "((?P<jitter>\S+)\s+)")

            regex = re.compile(exp, re.MULTILINE)
            r = regex.search(pay_dirt)

        data = {}

        if r:
            data = r.groupdict()
            print(data)


    def initialize(self,configurationFile=None):
        '''
        Initialize the probe.

        Returns:
        The probe name list.
        '''
        self._logger.log(Logger.DEBUG_LEVEL,
                         '/time/ntp initialize'
                         ' configuration: %s' % configurationFile)

        self._measurement = Measurement_time_ntp()

        self._measurement_ntp_labels = ('remote',
                                         'refid',
                                         'st',
                                         't',
                                         'when',
                                         'poll',
                                         'reach',
                                         'delay',
                                         'offset',
                                         'jitter')

        self._measurement.ntp.labels.extend(self._measurement_ntp_labels)

	return ('Time.NTP',)


    def start(self):
        self._logger.log(Logger.DEBUG_LEVEL,'/time/ntp start')


    def stop(self):
        self._logger.log(Logger.DEBUG_LEVEL,'/time/ntp stop')


    def destroy(self):
        self._logger.log(Logger.DEBUG_LEVEL,'/time/ntp destroy')


    def probe(self):
        self._logger.log(Logger.DEBUG_LEVEL,'/time/ntp probe')

        self.parse_ntp_parameters()

        return (('Time NTP',
                 self._measurement.SerializeToString(),
                 self._measurement.description.name,
                 self._measurement.description.module,
                 self._measurement.description.version),)

    def parse_ntp_parameters(self):
        del self._measurement.ntp.rows[:]

        dictio = NTP.dictio(self)

        for key in data:
                row = self._measurement.ntp.rows.add()

                # remote
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_STRING
                value.sValue = dictio.get('remote')

                # refid
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_STRING
                value.sValue = dictio.get('refid')

                # stratum
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                value.sValue = dictio.get('st')

                # t
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_STRING
                value.sValue = dictio.get('t')

                # when
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_STRING
                value.sValue = dictio.get('when')

                # poll
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                value.sValue = dictio.get('poll')

                # reach
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                value.sValue = dictio.get('reach')

                # delay
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_DOUBLE
                value.sValue = dictio.get('delay')

                # offset
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_DOUBLE
                value.sValue = dictio.get('offset')

                # jitter
                value = row.values.add()
                value.type = MeasurementTable.Measurement.TYPE_DOUBLE
                value.sValue = dictio.get('jitter')


def default_method_format(self, measurement):
    def fromMeasurement(measurement):
        if measurement.type == MeasurementTable.Measurement.TYPE_UINTEGER:
            return measurement.uValue,str(measurement.uValue)
        elif measurement.type == MeasurementTable.Measurement.TYPE_DOUBLE:
            return measurement.dValue,'%0.2f' % measurement.dValue
        else:
            return measurement.sValue,measurement.sValue


    def format_table(table):
        buf = ''

        widths = [];

        for label in table.labels:
            widths.append(len(label))

        for row in table.rows:
            for i,value in enumerate(row.values):
                widths[i] = max(widths[i],len(fromMeasurement(value)[1]))

        for i,label in enumerate(table.labels):
            buf += '|' + label.ljust(widths[i])
        buf += "|\n"

        for row in table.rows:
            for i,value in enumerate(row.values):
                val = fromMeasurement(value)[1]
                buf += '|' + val.rjust(widths[i])
            buf += "|\n"

        return buf

    buf = '[] ntp\n'
    buf += format_table(measurement.ntp)
    buf += '--\n'

    return buf
